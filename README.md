I. Purpose

    This repository is my solution to the 2019 Jr. Coding Challenge from
    Mountain State Software Solutions.

II. Getting Started

    This repository is set up to be bult with Maven. To set up, use the included
    pom.xml and ensure that sqlite-jdbc-3.30.1.jar is in the base project directory.
    It can then be run as a Maven project at command line or on your preferred IDE.

    This program takes 1 argument as input. That argument is the name of a file in the 
    included input directory WITHOUT the file extension.
    
III. Design

    a. Dependencies
       This project relies on 3 dependencies, Maven, sqlite-jdbc, and openCSV.
       I decided to use Maven to learn the tool and streamline running this project.
       I needed a way to interact with the database and sqlite-jdbc seemed a good solution.
       I used openCSV instead of parsing the CSV myself since they likely made it
       more efficient than I'd be able to with the time I have and it handles special cases
       like commas in quotes easily.

    b. Design
        - Structure
            I had originally designed this code in 3 parts, reading the input CSV, checking 
            each row's validity, and writing the result ot the correct file. The first two were
            done in Driver.java because validation was only really 1 function worth of work and 
            reading was being handled by openCSV. Distributor was enough functionality to separate
            it from Driver in its own logical chunk.

        -Efficiency
            When profiling and fixing this code for efficiency, I had to major categories to get right,
            String operations and database operations.
            
            Strings:
                The first part of this was using length() to reduce the number of times I read the string,
                the second was using StringBuilder for concatenation to maintain efficiency.

            Database:
                To make database operations efficient, I had to use as little of them as possible. It's why
                all the data is pushed to the database at once in its own function, writing line by line ate time.

        -Assumptions
            1.) There will only be columns A-J in a valid solution.
            2.) The customer doesn't want the input file deleted.
            3.) The customer won't try to use the output after manually stopping the program.
            4.) The customer can interpret error messages generated by the exceptions.
            5.) The customer won't attempt a SQLinjection attack on themselves.
            6.) Input files are correctly formatted.
            7.) Data should stay in the same order it was received in.